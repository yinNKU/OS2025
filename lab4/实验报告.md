## 1. 关键函数设计实现概述

### 1.1 alloc_proc
作用：仅负责“干净地”分配并初始化进程控制块（PCB）结构，不做重资源动作。主要初始化：
- state=PROC_UNINIT，pid=-1，runs=0，kstack=0，need_resched=0
- parent/mm/tf 设为 NULL，context 全零，pgdir 设为内核全局页表 `boot_pgdir_pa`（方便后续使用内核地址空间）
- flags=0，name 置零
设计要点：保持函数纯粹——不分配内核栈、不建立线程上下文，便于出错回收（do_fork 分步骤控制失败回滚）。

### 1.2 do_fork
完成“新内核线程”创建的核心逻辑，步骤（与代码一一对应）：
1. 资源上限检查（nr_process >= MAX_PROCESS）
2. alloc_proc：拿到 PCB
3. setup_kstack：为新线程分配内核栈页
4. copy_mm：本实验简化为共享（当前 mm==NULL）
5. copy_thread：将传入 trapframe 拷贝到新线程内核栈顶，设置：
	- tf->gpr.a0=0（子线程返回 0）
	- context.ra=forkret（第一次被调度时跳到 forkret -> forkrets -> 使用 trapframe 恢复）
	- context.sp=trapframe 起始地址
6. 分配唯一 pid：get_pid（线性扫描 + 跳过已占用 + next_safe 优化）
7. 继承父指针、设置 pgdir（共享内核页表）
8. 挂入全局链表 + 哈希表（便于遍历与 pid 查找）
9. wakeup_proc：state -> PROC_RUNNABLE
10. nr_process++；返回子 pid
异常回滚：每个可能失败点之后用 goto 路径依次释放栈 / PCB，避免泄漏。

### 1.3 proc_run
实现从 current 切换到目标进程：
1. 关中断（local_intr_save）防止上下文切换时被打断（保持一致性）
2. 保存 prev，更新全局 current=next
3. 切换地址空间：lsatp(next->pgdir) （共享内核页表，所以这里逻辑简单；若有用户地址空间，会换不同 satp）
4. 刷新 TLB：执行 sfence.vma（内联汇编）
5. switch_to(&prev->context,&next->context)：真正寄存器上下文切换（只保存/恢复 callee saved + ra + sp）
6. 开中断
设计分层：trapframe 不参与普通调度的频繁切换；只在进入内核（异常/中断/初始启动）时生成，常规调度用更轻量的 context。

## 2. proc_struct 中 context 与 trapframe 的区别与作用

| 成员 | 含义 | 内容范围 | 何时生成/更新 | 作用场景 |
|------|------|----------|---------------|----------|
| struct context context | 轻量级“调度上下文” | ra, sp, s0~s11（callee-saved） | do_fork/copy_thread 初次设置；switch_to 保存/恢复 | 进程/线程之间普通上下文切换（不涉及异常现场） |
| struct trapframe *tf | 完整陷入现场（通用寄存器 + CSR 关键字段） | 所有通用寄存器 + status/epc/badvaddr/cause | 由 copy_thread 创建或真实陷入入口保存（本实验只用 copy_thread 构造） | 返回用户/线程首次执行 or 异常返回（forkret -> forkrets） |

本实验情景：只有内核线程，trapframe 主要用于“模拟”第一次进入线程的启动环境（包含入口 epc，status 等），后续调度不再频繁读写它；常规切换只用 context，降低开销。

## 3. PID 唯一性分析

函数：get_pid()
- 递增 last_pid（越界后回绕为 1），并利用全局进程链表扫描冲突。
- 如果命中已存在 pid，继续递增；同时维护 next_safe = 当前扫描发现的“下一个空洞上界”。
- 防止 O(n^2) 退化：next_safe 用来减少重复扫描区间。
- MAX_PID > MAX_PROCESS：保证在不超上限的情况下总能找到空闲 pid。
结论：在当前单核、关中断上下文中（do_fork 内部没有并发竞争），get_pid 逻辑保证新 fork 线程获得未被占用的 pid，故“唯一性”成立。若未来引入真正 SMP，需要对分配过程加锁或使用原子结构。

## 4. 本实验创建并运行的内核线程数量

启动阶段：
1. idleproc （pid=0）：通过 alloc_proc 创建，作为调度的“空转线程”，初始 need_resched=1 以驱动后续调度。
2. initproc （pid=1）：由 kernel_thread(init_main, ...) 创建 => 内核线程。其入口 epc=kernel_thread_entry，最终执行 init_main。

因此：共有 2 个内核线程被创建并运行（idle 与 init）。后续没有再 fork 其它线程（除非你主动新增）。

## 5.challenge
语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断

sync.h 中的实现：
1. __intr_save()：
   - 读取 sstatus 寄存器的 SSTATUS_SIE 位（即全局中断使能位，RISC‑V 的 - - - SIE）： read_csr(sstatus) & SSTATUS_SIE
   - 如果 SIE 为 1（中断当前是允许的），就调用 intr_disable() 将其关闭，然后返回 1；否则直接返回 0。
2. __intr_restore(bool flag)：
   - 如果 flag 为真，就调用 intr_enable() 恢复中断，否则什么也不做。
3. local_intr_save(x) / local_intr_restore(x) 只是把这两个内联函数包装为宏，便于调用并把保存值放到变量 x。

也就是（伪流程）:

1. 调用 local_intr_save(intr_flag)
   - intr_flag = __intr_save()
   - __intr_save 通过读 CSR(sstatus) 判断当前是否允许中断：
     - 若允许，则执行 intr_disable()（把 SIE 清 0），并返回 1。
     - 若已禁止，则返回 0。
2. 在临界区执行需要屏蔽中断的操作（例如上下文切换）。
3. 调用 local_intr_restore(intr_flag)
    - __intr_restore(intr_flag)：
      - 若 intr_flag == 1（说明调用前中断是开的），则调用 intr_enable()（把 SIE 置 1）。
      - 若 intr_flag == 0（调用前中断已经是关的），则不做任何操作，保持禁中断状态。

思考题
- get_pte() 的两段“几乎相同”的代码，实际上分别处理页表的不同层级：先检查/创建上层页目录项（pdep1），再检查/创建下层页目录项（pdep0）。两处代码相似是因为“页表每一层的逻辑是一样的”——检查该层条目是否有效，不存在时分配一页作为下一层页表并初始化，最后把该层条目设置为指向新 page table 的 pte。
- 在 RISC‑V 的不同页表模式（sv32 / sv39 / sv48）中，差别只是“层数”和“每层索引的位宽”，但每层需要做的工作（检查有效位、在需要时分配/初始化下一层页表、建立条目）是相同的，因此代码模式自然非常相像。
- 关于把查找和分配合并在一个函数里：这样写方便（常用场景：需要“查找或创建”），但也有缺点（隐藏副作用、难以区分“只读查找”和“可能会触发分配”的场合）。更好的做法是提供两个接口：一个只查找（不分配），一个查找并在需要时分配（或通过参数控制 create 行为）。同时，把层数相关逻辑抽象成循环/通用 walker，可以同时支持 sv32/sv39/sv48。
  
## 6. 小结
- alloc_proc 只做结构体零化与默认元数据填充；do_fork 组合所有资源与链表管理；proc_run 只做最小必要切换。
- context 面向调度最小保存集；trapframe 面向异常/初始进入的完整现场。
- get_pid 在本实验环境下保证唯一 pid；实际多核需加同步。
- 实验运行线程数：2（idleproc, initproc）。

