# Lab1 实验报告：最小可执行内核和启动流程

## 一、实验原理

### 1.1 实验目标

Lab1 的主要目标是构建一个最小可执行内核，理解操作系统从加电到运行的完整启动流程。本实验构建的内核具备以下功能：
- 能够在 QEMU 模拟器上成功启动
- 通过 OpenSBI 提供的服务进行格式化输出
- 进入死循环等待

### 1.2 RISC-V 启动流程

RISC-V 架构定义了多个特权级别：
- **M-Mode (Machine Mode)**：最高权限级别，可直接访问所有硬件
- **S-Mode (Supervisor Mode)**：操作系统内核运行的权限级别
- **U-Mode (User Mode)**：用户程序运行的权限级别

完整的启动流程分为三个阶段：

#### 阶段1：MROM 固件启动 (0x1000)
- QEMU 模拟器加电后，PC 被设置为复位地址 `0x1000`
- 这里存放着 QEMU 内置的 MROM (Machine ROM) 固件
- MROM 的功能：读取硬件线程 ID，加载 OpenSBI 入口地址，跳转到 OpenSBI

#### 阶段2：OpenSBI 初始化 (0x80000000)
- OpenSBI 运行在 M-Mode，负责硬件初始化
- 主要任务：
  - 初始化 CSR 寄存器
  - 设置物理内存保护 (PMP)
  - 初始化中断和异常处理
  - 将内核镜像加载到 `0x80200000`
  - 跳转到内核入口

#### 阶段3：内核启动 (0x80200000)
- 内核运行在 S-Mode
- entry.S：设置栈指针，准备 C 语言运行环境
- `kern_init()`：执行内核初始化，输出信息

### 1.3 OpenSBI 的作用

**OpenSBI (Open Supervisor Binary Interface)** 是 RISC-V 架构的标准固件，扮演两个重要角色：

1. **Bootloader（引导加载程序）**
   - 初始化硬件环境
   - 加载操作系统内核到指定内存地址(见后续实验过程中的t0)
   - 将控制权移交给内核

2. **运行时服务提供者**
   - 内核运行在 S-Mode，无法直接执行某些特权操作
   - OpenSBI 提供 SBI 调用接口，通过 `ecall` 指令为内核提供服务
   - 例如：控制台输出、定时器设置、系统关机等

### 1.4 代码结构与设计

#### 启动相关代码
- **entry.S**：汇编入口，设置栈指针，跳转到 C 代码
- **init.c**：C 语言入口，`kern_init()` 函数
- **kernel.ld**：链接脚本，指定内核加载地址为 `0x80200000`

#### 硬件抽象层
- **`libs/sbi.c/sbi.h`**：封装 SBI 调用，提供与 OpenSBI 通信的接口
- **console.c**：控制台驱动，基于 SBI 实现字符输出
- **stdio.c**：标准 I/O 库，提供 `cprintf` 等函数
## 二、实验过程
### 2.1 调试步骤
#### 步骤1：连接 GDB 到 QEMU
$ make gdb
Reading symbols from bin/kernel...
The target architecture is set to "riscv:rv64".
Remote debugging using localhost:1234
0x0000000000001000 in ?? ()

**说明**：GDB 成功连接，CPU 停在复位地址 `0x1000`
$
#### 步骤2：查看 MROM 固件代码

gdb
(gdb) x/10i $pc
=> 0x1000:      auipc   t0,0x0
   0x1004:      addi    a1,t0,32
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      t0,24(t0)
   0x1010:      jr      t0


**代码分析**：
- `0x1000: auipc t0,0x0` - 将当前 PC 值加载到 t0
- `0x1004: addi a1,t0,32` - 计算参数地址（可能是设备树地址）
- `0x1008: csrr a0,mhartid` - 读取硬件线程 ID
- `0x100c: ld t0,24(t0)` - 从 0x1018 加载 OpenSBI 入口地址
- `0x1010: jr t0` - 跳转到 OpenSBI

**代码来源**：QEMU MROM 固件（模拟器内置，不在工作区）
#### 步骤3：单步执行 MROM 代码直到openSBI被加载
gdb
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) info r t0
t0             0x1000   4096
**说明**：执行了前三条指令，t0 寄存器保存着基地址 `0x1000`
gdb
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r t0
t0             0x80000000       2147483648
**说明**：执行 `ld t0,24(t0)` 后，t0 现在指向 OpenSBI 的入口地址 `0x80000000`
gdb
(gdb) si
0x0000000080000000 in ?? ()
**说明**：执行 `jr t0`，成功跳转到 OpenSBI！此时 PC = `0x80000000`

**代码来源**：OpenSBI 固件（QEMU 加载到内存）
#### 步骤4：设置断点，跳过 OpenSBI 初始化
gdb
(gdb) break *0x80200000
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.

(gdb) continue
Continuing.

Breakpoint 1, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
**说明**：
- 在内核入口 `0x80200000` 设置断点
- `continue` 命令让 OpenSBI 执行完成（数千条指令）
- 到达断点时，OpenSBI 已将内核加载到内存并跳转过来
#### 步骤7：查看并执行内核入口代码，运行到输出完成

gdb
(gdb) x/10i $pc
=> 0x80200000 <kern_entry>:     auipc   sp,0x3
   0x80200004 <kern_entry+4>:   mv      sp,sp
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>

**代码分析**：
- `la sp, bootstacktop` 被编译成两条指令：
  - `auipc sp,0x3` - 计算栈顶地址
  - `mv sp,sp` - 移动栈指针（可能是对齐优化）
- `tail kern_init` 被编译成：
  - `j 0x8020000a` - 跳转到 kern_init 函数

gdb
(gdb) si
0x0000000080200004 in kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop

(gdb) si
9           tail kern_init

(gdb) si
kern_init () at kern/init/init.c:8
8           memset(edata, 0, end - edata);


**说明**：
- 第一个 `si`：执行 `auipc sp,0x3`，设置栈指针
- 第二个 `si`：执行 `mv sp,sp`，完成栈指针设置
- 第三个 `si`：执行 `j kern_init`，跳转到 C 函数
gdb
(gdb) si
0x000000008020000e      8           memset(edata, 0, end - edata);

(gdb) break kern/init/init.c:12
Breakpoint 2 at 0x8020003a: file kern/init/init.c, line 12.

(gdb) continue
Continuing.

Breakpoint 2, kern_init () at kern/init/init.c:12
12         while (1)

**说明**：
- 在 `while(1)` 死循环处设置断点
- `continue` 让代码执行完print之前所调用的一大堆代码
- 到达断点时，输出已完成

#### 步骤10：查看 QEMU 输出

**切换到终端1（make debug 窗口）**，可以看到：


OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
(THU.CST) os is loading ...
**说明**：
- 前面是 OpenSBI 的输出信息
- 最后一行 `(THU.CST) os is loading ...` 是内核的输出

## 三、问题解答

### 练习1：理解内核启动中的程序入口操作

**问题1：`la sp, bootstacktop` 完成了什么操作，目的是什么？**

**操作分析**：

1. **指令含义**：
   - `la` (load address) 是 RISC-V 的伪指令，用于将一个地址加载到寄存器
   - `sp` 是栈指针寄存器 (stack pointer)
   - `bootstacktop` 是在 entry.S 中定义的符号，表示内核栈的栈顶地址

2. **代码定义**：
   asm
   .section .data
   .align PGSHIFT        # 按页对齐 (2^12 = 4096字节)
   .global bootstack
   bootstack:
       .space KSTACKSIZE     # 分配 8192 字节的栈空间
   .global bootstacktop
   bootstacktop:             # 栈顶标记（高地址端）
   

3. **编译结果**：
   从 GDB 调试可以看到，`la` 被展开为：
   asm
   0x80200000: auipc sp,0x3    # sp = PC + (0x3 << 12)
   0x80200004: mv sp,sp        # 移动栈指针
   

4. **执行效果**：
   - 将 `bootstacktop` 的地址（约 `0x80203000`）加载到 `sp` 寄存器
   - 栈空间从 `bootstack` 开始，大小为 `KSTACKSIZE = 8KB`
   - `sp` 指向栈顶（高地址端）

5. **目的**：
   - **为 C 语言代码准备运行环境**：C 语言函数需要栈来保存局部变量、函数参数、返回地址和保存的寄存器值
   - **设置栈向下增长**：RISC-V 的栈从高地址向低地址增长，所以 `sp` 初始化为栈顶
   - **过渡到高级语言**：这是从汇编语言过渡到 C 语言的必要准备步骤

**问题2：`tail kern_init` 完成了什么操作，目的是什么？**

**操作分析**：

1. **指令含义**：
   - `tail` 是 RISC-V 的伪指令，用于尾调用 (tail call)
   - `kern_init` 是在 init.c 中定义的 C 语言函数

2. **编译结果**：
   从 GDB 调试可以看到，`tail` 被展开为：
   asm
   0x80200008: j 0x8020000a <kern_init>
   
   这是一条无条件跳转指令 `j` (jump)

3. **执行效果**：
   - 直接跳转到 `kern_init` 函数的入口地址
   - **不保存返回地址**（不使用 `ra` 寄存器）
   - 不占用额外的栈空间

4. **目的**：
   - **将控制权从汇编代码转移到 C 语言代码**：标志着内核启动的第一阶段（汇编初始化）结束，进入第二阶段（C 语言初始化）
   - **使用 tail 而不是 call 的原因**：
     - `kern_init` 函数被声明为 `noreturn`（永远不会返回）
     - 使用 `tail` 调用可以节省栈空间（不需要保存返回地址）
     - 这是一种针对不返回函数的优化技术
   - **简化调用链**：避免不必要的函数返回机制

### 练习2：使用GDB验证启动流程

**问题：RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？**
#### 1. 初始执行地址

**地址：`0x1000`**

这是 QEMU 模拟的 RISC-V 硬件的复位地址（reset vector）。在真实的 RISC-V 硬件中，这段代码位于芯片内部的 ROM 中。

#### 2. 前5条指令的详细功能

**指令1：`0x1000: auipc t0, 0x0`**
- **功能**: 将当前指令地址加上立即数 `0x0`，结果存储到寄存器 `t0` 中。
- **目的**: 初始化 `t0` 寄存器，通常用于后续地址计算。

**指令2：`0x1004: addi a2, t0, 40`**
- **功能**: 将寄存器 `t0` 的值加上立即数 `40`，结果存储到寄存器 `a2` 中。
- **目的**: 设置 `a2` 寄存器的值，可能用于后续的内存访问或参数传递。

**指令3：`0x1008: csrr a0, mhartid`**
- **功能**: 从控制和状态寄存器 `mhartid` 中读取当前硬件线程 ID，存储到寄存器 `a0` 中。
- **目的**: 获取当前执行的硬件线程的标识，通常用于多线程环境中的调试或状态管理。

**指令4：`0x100c: ld a1, 32(t0)`**
- **功能**: 从地址 `t0 + 32` 处加载一个双字（64位）到寄存器 `a1` 中。
- **目的**: 读取内存中的数据，加载设备树(DTB)地址或其他启动参数

**指令5：`0x1010: ld t0, 24(t0)`**
- **功能**: 从地址 `t0 + 24` 处加载一个双字到寄存器 `t0` 中。
- **目的**: 更新 `t0` 寄存器的值，用于指令跳转。

**指令6：`0x1014: jr t0`**
- **功能**: 跳转到`t0`地址。
- **目的**: 将控制权交给openSBI。

#### 3. 总体功能总结

这5条指令构成了 **最小的启动引导程序 (MROM)**，它的功能是：

1. **获取位置信息**：通过 `auipc` 指令获取当前代码的基地址
2. **准备参数**：设置设备树地址和硬件线程 ID
3. **读取跳转目标**：从固定位置读取 OpenSBI 的入口地址
4. **完成第一次权力交接**：跳转到 OpenSBI，将控制权从 MROM 转移到 OpenSBI

#### 4. 完整启动链


MROM (0x1000)  →  OpenSBI (0x80000000)  →  内核 (0x80200000)
[5条指令]         [数千条指令]              [ucore代码]
[M-Mode]          [M-Mode]                 [S-Mode]


**特权级变化**：
- MROM 和 OpenSBI 都运行在 M-Mode（最高权限）
- OpenSBI 在跳转到内核前，会将 CPU 切换到 S-Mode（内核态）
- 内核从此运行在 S-Mode，需要通过 `ecall` 请求 OpenSBI 的服务



