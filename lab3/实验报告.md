#  练习1：完善中断处理
## 实现过程简述

本次实验在 `kern/trap/trap.c` 中完成时钟中断（Supervisor Timer Interrupt, `IRQ_S_TIMER`）的处理逻辑，使内核每累计 100 次时钟中断打印一次“100 ticks”，累计打印 10 次后关机。

关键修改点：

- 在 `interrupt_handler(struct trapframe *tf)` 的 `case IRQ_S_TIMER:` 分支内实现：
  - 调用 `clock_set_next_event()` 预约下一次时钟中断（该调用也会清除 STIP）。
  - 全局计数器 `ticks` 自增（`ticks++`）。
  - 当 `ticks % TICK_NUM == 0`（`TICK_NUM` 为 100）时：
	 - 调用 `print_ticks()` 打印“100 ticks”。
	 - 记录打印次数 `tick_prints++`。
	 - 当 `tick_prints == 10` 时，调用 `sbi_shutdown()` 关机。

相关支撑：

- `kern/driver/clock.c` 中的 `clock_init()` 负责开启 S 态定时器中断（`set_csr(sie, MIP_STIP)`）并调用 `clock_set_next_event()` 进行首次预约，且初始化全局变量 `ticks = 0`。
- `clock_set_next_event()` 通过 `sbi_set_timer(get_cycles() + timebase)` 预约下一次定时器事件。
- `ticks` 定义为 `volatile size_t`，避免编译器优化导致的读写丢失。


## 定时器中断处理流程

按时间顺序，RISC-V S 态定时器中断的处理链路如下：

1. 初始化阶段
	- `clock_init()`：
	  - 置位 `sie` 中的 `MIP_STIP` 位，开启 S 态时钟中断响应。
	  - 调用 `clock_set_next_event()` 预约第一次时钟事件。
	  - 将全局时钟计数 `ticks` 清零。

2. 定时器触发
	- 当时间到达预约点，硬件置位 `SIP.STIP`，触发 S 态定时器中断。
	- 处理器根据 `stvec` 跳转到异常入口 `__alltraps`（见 `trapentry.S`）。

3. 入口与分发
	- `__alltraps` 保存通用寄存器并构造 `trapframe`，随后跳转到 C 函数 `trap(tf)`。
	- `trap()` 调用 `trap_dispatch(tf)`，根据 `tf->cause` 的符号位区分中断/异常：中断走 `interrupt_handler(tf)`。

4. 时钟中断分支（`IRQ_S_TIMER`）
	- 调用 `clock_set_next_event()` 预约下一次时钟事件（同时清除本次 STIP）。
	- `ticks++`。
	- 若 `ticks % 100 == 0`：
	  - 调用 `print_ticks()` 打印 “100 ticks”。
	  - `tick_prints++`；当 `tick_prints == 10` 时，调用 `sbi_shutdown()` 关机。

5. 返回现场
	- 处理完毕后返回 `trapentry`，恢复寄存器现场并执行 `sret` 返回到被中断的位置继续执行。

以上流程保证了：系统以 100 次中断为一个“节拍”打印进度，并在打印 10 次后有序关机，符合实验要求。

# 扩展练习1：描述与理解中断流程

下面结合 uCore-RISCV 的实现，说明从异常/中断产生到返回的完整路径，并回答若干关键问题。

## 从异常产生到返回的处理路径

1. 异常/中断产生
	 - 硬件在到达触发条件（如定时器到期）后置位相应挂起位（如 `SIP.STIP`），并在 `SSTATUS.SIE` 打开时，根据 `STVEC` 跳转到异常入口。

2. 进入异常向量 `__alltraps`（见 `kern/trap/trapentry.S`）
	 - 执行 `SAVE_ALL`：
		 - 先用 `csrw sscratch, sp` 暂存原始 `sp`。
		 - 在当前栈上分配 `trapframe` 空间：`addi sp, sp, -36 * REGBYTES`。
		 - 依固定偏移保存通用寄存器（见下文“保存位置如何确定”）。
		 - 读取并保存 `sstatus/sepc/sbadaddr/scause` 到 `trapframe` 尾部。
	 - 将 `trapframe` 的地址放入 `a0`：`move a0, sp`（RISC-V 等价于 `mv a0, sp`）。
	 - `jal trap` 进入 C 函数 `trap(struct trapframe *tf)`。

3. C 端分发与处理（见 `kern/trap/trap.c`）
	 - `trap()` -> `trap_dispatch()`：根据 `tf->cause` 的最高位判断中断/异常；
		 - 中断：进入 `interrupt_handler(tf)`（如 `IRQ_S_TIMER` 的时钟中断）。
		 - 异常：进入 `exception_handler(tf)`（如非法指令、断点等）。

4. 处理结束返回
	 - 回到汇编标签 `__trapret`，执行 `RESTORE_ALL` 按相同偏移恢复寄存器与 `sstatus/sepc`。
	 - 执行 `sret` 返回被打断点继续执行。

## “move a0, sp”的目的是什么？

- 目的：把当前栈顶处构造好的 `trapframe` 的地址（即保存了完整上下文的结构体）放到 `a0`，作为 C 函数 `trap(struct trapframe *tf)` 的第一个参数（遵循 RISC-V ABI）。
- 背景：`SAVE_ALL` 已经将现场保存到以 `sp` 为基地址的内存区域，因此直接把 `sp` 作为 `trapframe*` 传入最简洁可靠。

## SAVE_ALL 中寄存器保存在栈中的位置如何确定？

- 规则由 C 端结构体定义决定：
	- `kern/trap/trap.h` 中的 `struct pushregs` 与 `struct trapframe` 明确了字段顺序：
		- 前 32 个槽位为通用寄存器，顺序为 `zero(x0), ra(x1), sp(x2), gp(x3), tp(x4), t0..t2, s0..s1, a0..a7, s2..s11, t3..t6`。
		- 随后依次是 `status、epc、badvaddr、cause` 共 4 个槽位。
	- `trapentry.S` 中使用与之严格一致的偏移（单位为 `REGBYTES`，在 32/64 位平台自动取 4/8 字节）。
- 关于 `sp`（x2）的保存：
	- 由于一开始 `sp` 被下移并用于作为 `trapframe` 的基址，代码先用 `sscratch` 暂存原始 `sp`，再通过 `csrrw` 取回保存到偏移 `2*REGBYTES(sp)`，从而与 `struct pushregs` 中 `sp` 字段的位置匹配。

## __alltraps 是否需要为任何中断都保存“所有寄存器”？

- uCore 的设计是：是的，统一保存全部通用寄存器（再加上 `sstatus/sepc/sbadaddr/scause`）。
- 理由：
	1. 安全与通用性：异常/中断可能发生在任意指令处，事先无法知道哪些寄存器是“活跃”的，统一全保存可确保返回时现场完整无误。
	2. C 处理函数可调用任意子函数：C 调用栈会使用/破坏若干寄存器（包括 caller-saved 与 callee-saved），全保存避免约束处理代码的实现自由度。
	3. 支持嵌套与调度：统一格式的 `trapframe` 便于调试、打印、以及作为上下文切换的载体（调度器可直接切换 `trapframe`）。
- 可选优化（本实验不做）：某些场景下可仅保存最小子集（如仅 caller-saved 或按 `cause` 分类保存），但需严格证明对嵌套/抢占/编译器优化安全，复杂度较高且收益有限。

# 扩展练习2： 理解上下文切换机制

## 关于 `csrw sscratch, sp` 与 `csrrw s0, sscratch, x0` 的含义与目的

- `csrw sscratch, sp`：把当前的栈指针 `sp` 写入到 S 态临时寄存器 `sscratch`。这一步用于暂存“进入陷入前”的原始 `sp`，因为随后需要下移 `sp` 并在栈上构造 `trapframe`。
- `csrrw s0, sscratch, x0`：读写交换操作（atomic read-write）。其效果是：
	- 将 `sscratch` 的旧值（也就是前面保存的“原始 sp”）读到 `s0`；
	- 同时把寄存器 `x0`（恒为 0）写回到 `sscratch`，即把 `sscratch` 置 0。

这样做的两个目的：
1) 获取原始 `sp` 并按固定偏移保存在 `trapframe` 中，以匹配 `struct pushregs` 的 `sp` 槽位（随后用 `STORE s0, 2*REGBYTES(sp)` 完成保存）。
2) 将 `sscratch` 清零，作为“陷入时来自内核态”的标识。若后续发生递归异常，异常向量可以据此判断上下文来源，避免把用户态/内核态路径混淆（对应源码注释：“Set sscratch register to 0, so that if a recursive exception occurs, the exception vector knows it came from the kernel”）。

## 为什么 SAVE_ALL 保存了 `stval/scause`，但 RESTORE_ALL 不恢复它们？

- 保存它们的意义：
	- `scause`（在本工程中保存在 `trapframe.cause`）和 `stval`/`sbadaddr`（保存在 `trapframe.badvaddr`）描述了“这次陷入的原因与相关地址/值”。C 端的 `trap()/interrupt_handler()/exception_handler()` 需要读取这些字段来做分发、处理与调试打印（例如非法指令、缺页等需要根据 `cause`/`badaddr` 决策）。
	- 将这些 CSR 的值纳入 `trapframe`，还能便于统一打印、记录日志、或在特殊处理里修改 `sepc`（比如跳过出错指令）。

- 不恢复它们的原因：
	- 返回路径只依赖 `sstatus` 和 `sepc` 两个关键 CSR：`sstatus` 决定返回后的特权/中断位，`sepc` 是返回地址；执行 `sret` 即可恢复执行流。
	- `scause`/`stval` 是“描述本次陷入”的信息，并不会影响 `sret` 的控制流恢复；即便它们在 S 态可写，也没有恢复它们的必要。此外，恢复它们还可能掩盖真实的陷入信息，影响调试/诊断。

因此，SAVE_ALL 保存 `sstatus/sepc/stval/scause` 供软件栈使用，而 RESTORE_ALL 仅恢复“会影响返回”且必须准确还原的 `sstatus/sepc`，这是最小且正确的恢复集合。
