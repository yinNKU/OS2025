# 实验二：物理内存管理 实验报告



## 实验环境与运行结果概览

- 平台：QEMU RISC-V (virt)
- 关键输出：
	- memory management: slub_pmm_manager
	- physcial memory map: 128MB from 0x80000000
	- [pmm] pages=0xffffffffc0206000 npage=557056 nbase=524288 pages_array_bytes=1310720 freemem=0x0000000080346000
	- check_alloc_page() succeeded!
	- satp 虚拟/物理地址正确打印

说明：完成了默认 First-Fit、Best-Fit 两种连续页分配器的理解与实现，并实现了扩展练习 SLUB（页级 + 任意大小对象）的两层分配器，集成到 pmm 框架，并通过自检用例。

---

## 练习1：理解 First-Fit 连续物理内存分配算法

参考文件：`kern/mm/default_pmm.c`

### 设计与数据结构

- `struct Page`：记录页的引用计数 `ref`、标志位 `flags`、连续空闲块头的大小 `property` 以及链表节点 `page_link`。
- `free_area_t`：维护空闲块头的双向链表 `free_list` 和空闲页总数 `nr_free`。
- 关键宏：
	- `SetPageProperty/ClearPageProperty/PageProperty`：标记是否为空闲块头页；
	- `SetPageReserved/ClearPageReserved/PageReserved`：标记是否为保留页（不可分配）。

### 核心流程

- 初始化 `default_init`：初始化空闲链表与计数。
- 建表 `default_init_memmap(base, n)`：
	- 将 [base, base+n) 中每个 Page 的 `flags/property/ref` 清零；
	- 仅将 `base` 标记为块头：`base->property = n; SetPageProperty(base);`
	- 将块头按地址有序插入 `free_list`，`nr_free += n`。
- 分配 `default_alloc_pages(n)`：
	- 从 `free_list` 遍历，寻找第一个 `p->property >= n` 的块头；
	- 删除该块头节点，若大于 `n`，在 `page+n` 位置产生新的块头并插回链表；
	- `nr_free -= n; ClearPageProperty(page)`，返回 `page`。
- 释放 `default_free_pages(base, n)`：
	- 确认区间内页均未保留/未属性；清零标志与引用；
	- 将 `base` 标记为新块头并插入有序空闲链表；
	- 与前驱连续则前驱吸收当前：更新前驱 `property`，清除当前 `PageProperty` 并从链表删除；
	- 与后继连续则当前吸收后继：更新当前 `property`，清除后继 `PageProperty` 并从链表删除。

### 复杂度与改进空间

- 当前实现：
	- 分配/释放均可能 O(K) 遍历空闲块数量；
	- 块拆分/合并为 O(1)。
- 改进：
	- 用分级空闲链/按大小排序 + 辅助树结构（如平衡树）降低查找复杂度；
	- 延迟合并或快速合并策略；
	- 碎片优化：适当合并小块或页框回收策略。

---

## 练习2：实现 Best-Fit 连续物理内存分配算法

参考文件：`kern/mm/best_fit_pmm.c`

### 设计要点

- 在 First-Fit 基础上修改分配策略：遍历空闲链表，选取满足 `p->property >= n` 且 `p->property` 最小的块头。
- 初始化、释放与合并流程与 default 基本一致，依然保持地址有序链表，便于相邻合并。

### 关键代码片段（逻辑描述）

- 选块：
	- 遍历空闲链表，维护 `min_size` 和 `best` 指针，选出最佳块；
	- 若最佳块大于 n，按 `best + n` 进行尾部分裂并回链。

### 复杂度与改进空间

- 复杂度与 First-Fit 一样为 O(K) 遍历；
- 改进可采用按大小分类的 bin 或平衡树来加速最佳块定位；需要在释放时维护多索引结构。

---

## 扩展练习 Challenge：SLUB 分配器（两层架构）

参考文件：`kern/mm/slub_pmm.c`，并在 `pmm.c` 中挂接 `slub_pmm_manager`。

### 目标与架构

- 两层分配：
	1) 页级分配器：用“简化 best-fit”的空闲块管理，接口与 pmm_manager 对齐；
	2) 对象分配器（SLUB）：面向任意（小于等于一页）对象大小的高效分配。

### 数据结构

- 页级：
	- `free_area_t slub_free_area` + 地址有序链 `slub_free_list` + 计数 `slub_nr_free`。
	- 块头 `PageProperty=1, property=#pages`；非头页 `PageProperty=0`。
- SLUB：
	- `kmem_cache_t`：每种对象大小一个 cache（类）；维护 `partial/full/empty` 三个 slab 链表；
	- `slab_t`：位于每页开头，记录 `cache`、`inuse/total`、`free_head`（对象索引 freelist 头）；
	- 尺寸类：`{16,32,64,128,256,512,1024,2048}`，对齐至少为 `sizeof(void*)`。

### 关键算法

- 页级初始化 `slub_page_init_memmap`：清零区间页的 flags/property/ref，`base` 作为块头插回有序空闲链。
- 页级分配 `slub_page_alloc_pages(n)`：
	- 遍历空闲链表，找 `p->property >= n` 的“最佳”块；
	- 如剩余 > n，按 `best+n` 产生新块头插回；
	- 清除 `best` 的 `PageProperty` 并减少 `slub_nr_free`；
	- 返回首页。
- 页级释放合并 `slub_page_free_pages(base,n)`：
	- 检查范围内页不带 Reserved/Property；清零 flags/ref；
	- 设置 `base` 为新块头并插回有序链；
	- 与前驱连续则前驱吸收当前：更新 `pp->property += base->property`，清除 `base` 的 `PageProperty` 与 `property=0`，删除 `base` 链接；
	- 与后继连续则当前吸收后继：更新 `base->property += pn->property`，清除 `pn` 的 `PageProperty` 与 `property=0`，删除 `pn` 链接。

 备注：这一步修复了一个潜在 bug——若不清理被吸收块头的属性位，会在后续释放时触发断言。

- SLUB 建 slab：页级分配一页，将页首作为 `slab_t`，其余作为对象区；对象区用“对象内嵌 16-bit next 索引”的方式管理 freelist。
- kmalloc：选择合适尺寸类 cache；优先从 `partial` 取 slab，否则从 `empty` 取并移入 `partial`，若都无则创建新 slab；从 slab 的 freelist 弹出对象，满则移入 `full`。
- kfree：根据对象地址定位所在 slab（页对齐取 slab 头）；将对象压回 freelist，inuse--；若 inuse==0，销毁 slab 并归还页；否则确保在 `partial` 中。

### 接口契约与正确性

- 契约：`PageProperty=1` 仅在空闲块头页；合并后必须清理被吸收块头属性，确保链表仅包含真实块头。
- 自检：`slub_check()` 覆盖页级分配/合并、地址往返映射、SLUB 多 slab 分配/释放序列，最后空闲页计数回到初始值。

### 复杂度与边界

- 页级分配 O(K)，释放 O(1) 合并 + O(K) 插入；
- SLUB 每次分配/释放基本 O(1)；容量计算考虑对齐与 `slab_t` 头，若对象太大容量为 0 则放弃。
- 边界：
	- kmalloc(0) 返回 NULL；
	- 超过最大尺寸类返回 NULL（可扩展到多页 slab，但本实验简化为一页 slab）。


- 在页级合并时，显式清理被吸收块头页的 `PageProperty` 与 `property=0`，避免隐藏状态污染；
- 调整内核 `cprintf` 的 `%zu` 为 `%lu`，避免最小 printf 不支持 `%zu` 导致日志混乱。

### 测试说明

- 内置 `slub_check()`：
	- 分配 1/2/3 页，检查空闲计数；
	- 释放并跨顺序合并，验证 best-fit 分配能取到合并出来的精确块；
	- 进行 64B 对象的批量分配/释放，跨多个 slab，并在释放后检查空闲页计数是否恢复。

运行验证：QEMU 启动正常，自检通过，无 panic。

---

## 重要知识点总结与原理映射

- 物理内存探测与 DTB：
	- 原理：OpenSBI/Bootloader 提供设备树，OS 解析 DRAM 范围；
	- 实验：`dtb.c` 获取 base/size，`pmm.c:page_init()` 通过 DTB 设置 `npage/pages/freemem` 后建立空闲链。

- 页框描述与双向链表管理：
	- 原理：为每个页框建立元信息结构（flags/ref/property）；
	- 实验：`struct Page` + `list.h` 维护空闲块头链；按地址有序便于相邻合并。

- 连续物理内存分配策略：First-Fit vs Best-Fit：
	- 原理：不同策略下外部碎片与搜索代价权衡；
	- 实验：`default_pmm.c` 与 `best_fit_pmm.c` 的实现与测试。

- 高地址映射与页表启用：
	- 原理：内核高半区映射，SATP/Sv39，大页映射；
	- 实验：`entry.S` 预置三级页表，将 0xffffffffc0000000~ 映射到 0x80000000~。

- SLUB 小对象分配：
	- 原理：按尺寸类的 slab，嵌入式 freelist，最小元数据开销；
	- 实验：`slub_pmm.c` 中以页为 slab，头放页首，空闲对象用 16-bit 索引链接，空 slab 立即归还页，简化但体现主体思想。

### 实验与原理的差异/取舍

- 简化：
	- SLUB 未实现对象构造/析构、cache 对齐/颜色化、NUMA、跨页 slab、大对象分配等；
	- 页级分配未采用复杂数据结构优化搜索复杂度。
- 强调：
	- 契约清晰（块头唯一性、属性位语义），便于验证与扩展；
	- 自检覆盖合并边界与对象级回收。

---

## 原理重要但本实验未覆盖的内容

- 伙伴系统（Buddy）与高阶页管理、抗碎片策略。
- Slab/SLUB 的 kmem_cache_ctor/dtor、对象对齐与 cache 合并、延迟回收、每 CPU 变量与缓存对齐、NUMA 感知。
- 页面替换算法（FIFO/LRU/Clock）与缺页异常处理。
- 虚拟内存权限隔离（用户/内核态）、Copy-on-Write、内存映射文件、匿名映射等。
- IOMMU 与 DMA 映射，页面锁定与高端内存管理。

---

## 遇到的问题与解决

- 问题：释放页块合并时未清理被吸收块头的 `PageProperty`，导致后续释放触发断言（日志中 flags=2/prop=2）。
	- 解决：在 `slub_page_free_pages` 的前驱/后继合并中，显式 `ClearPageProperty()` 并将被吸收头的 `property=0`。

- 问题：`cprintf` 不支持 `%zu`，日志出现 `%zu` 字面量。
	- 解决：统一改为 `%lu` 并进行 `(unsigned long)` 强制转换。

---

## 代码位置索引

- First-Fit：`kern/mm/default_pmm.c`
- Best-Fit：`kern/mm/best_fit_pmm.c`
- SLUB 两层分配器：`kern/mm/slub_pmm.c`
- 管理器接入：`kern/mm/pmm.c`（`pmm_manager = &slub_pmm_manager;`）
- 核心结构体/宏：`kern/mm/memlayout.h`，链表：`libs/list.h`

---

## 练习3：硬件的可用物理内存范围的获取方法
核心思路是​​通过固件提供的标准接口来查询硬件信息。


| 探测方法 | 工作机制简介 | 
| :--- | :--- |
| **BIOS 中断 `0x15`，子功能 `0xE820`** | 通过多次调用中断，固件迭代返回多个**地址范围描述符（ARDS）**，每个描述符告知操作系统一段内存的起始地址、长度和类型（如可用、保留等）。 | 
| **BIOS 中断 `0x15`，子功能 `0xE801`** | 一种简化的方法，将内存分为两部分检测：0-15MB区域和16MB-4GB区域，结果分别存放在不同的寄存器中。 | 
| **BIOS 中断 `0x15`，子功能 `0x88`** | 最简单的方法，调用后直接返回1MB地址以上、最多64MB范围内的内存大小（以KB为单位）。 |
| **通过 SBI HSM 扩展获取** | 调用 SBI 接口获取内存区域数量，查询具体的内存区域信息，通过标志位区分可用内存和保留内存|
 **通过平台特定接口获取**|通过 sbi_platform_ptr 获取平台信息结构体，遍历平台定义的内存区域数组，检查区域的可用性标志|
 |**保守内存探测**|从已知安全地址开始逐页测试读写，检查是否能成功写入和读取数据。|

