# 实验二：物理内存管理 实验报告



## 实验环境与运行结果概览

- 平台：QEMU RISC-V (virt)
- 关键输出：
	- memory management: slub_pmm_manager
	- physcial memory map: 128MB from 0x80000000
	- [pmm] pages=0xffffffffc0206000 npage=557056 nbase=524288 pages_array_bytes=1310720 freemem=0x0000000080346000
	- check_alloc_page() succeeded!
	- satp 虚拟/物理地址正确打印

说明：完成了默认 First-Fit、Best-Fit 两种连续页分配器的理解与实现，并实现了扩展练习 SLUB（页级 + 任意大小对象）的两层分配器，集成到 pmm 框架，并通过自检用例。

---

## 扩展练习实验报告：Buddy System 伙伴系统分配算法实现

### 核心设计与架构
- “分块 - 合并”，将物理内存以 “页” 为单位，管理为大小为 2^n（n 为 order）的连续块，通过拆分大 block 满足小需求，释放时合并相邻空闲 block 减少碎片
  
### 数据结构
  1) buddy_free_areas:多级空闲块链表数组，每个索引对应一个order（块大小 2^order 页），存储该级别所有空闲块。
  2) buddy_nr_free：全局空闲页总数，用于快速判断内存是否充足。

### 算法实现
  - 初始化流程：
    1) buddy_page_list_init：初始化所有order级别的空闲链表，将链表置空、空闲计数归零。
    2) buddy_page_init_memmap：将一段连续物理内存（base开始的n页）初始化为伙伴系统管理的块：
        - 先清空所有页的状态（flags、property、引用计数）。
        - 按 “最大可能块” 原则拆分内存：从剩余内存中划分出最大的 2^n 块，标记块头并插入对应order的空闲链表。
        - 更新全局空闲页计数buddy_nr_free。
  - 分配流程：
    1) 通过get_min_order将n向上取整为最近的 2^order
    2) 通过buddy_page_list_add将块头插入对应order的空闲链表。
    3) 若找到的块级别高于目标级别，递归拆分该块为两个 “伙伴块”，将其中一个作为空闲块插回低一级链表，直到块级别等于目标级别。
    4) 从空闲链表中移除目标块，清除其 “块头” 标记，减少全局空闲页计数，返回块头页地址。
  - 释放流程：
    1) 确保释放的块大小是 2 的幂次（伙伴系统规则），且页非保留状态。
    2) 清空释放页的状态（flags、property、引用计数），标记base为块头。
    3) 将释放的块按地址升序插入对应order的空闲链表，更新空闲计数。
   
###  测试说明
  - 通过一组预设用例，验证伙伴系统的正确性，核心测试点包括：
      1) 非 2^n 分配校验：请求 3 页、5 页，验证实际分配的是 4 页（order=2）、8 页（order=3）。
      2) 释放合并校验：释放分配的块后，验证全局空闲页计数恢复为初始值，确保合并逻辑生效。
      3) 大块分配校验：尝试分配 16 页（若内存充足），验证大块的拆分与合并正确性。 
  - 测试结果：
   QEMU 启动正常，自检通过


---

## 练习1：理解 First-Fit 连续物理内存分配算法

参考文件：`kern/mm/default_pmm.c`

### 设计与数据结构

- `struct Page`：记录页的引用计数 `ref`、标志位 `flags`、连续空闲块头的大小 `property` 以及链表节点 `page_link`。
- `free_area_t`：维护空闲块头的双向链表 `free_list` 和空闲页总数 `nr_free`。
- 关键宏：
	- `SetPageProperty/ClearPageProperty/PageProperty`：标记是否为空闲块头页；
	- `SetPageReserved/ClearPageReserved/PageReserved`：标记是否为保留页（不可分配）。

### 核心流程

- 初始化 `default_init`：初始化空闲链表与计数。
- 建表 `default_init_memmap(base, n)`：
	- 将 [base, base+n) 中每个 Page 的 `flags/property/ref` 清零；
	- 仅将 `base` 标记为块头：`base->property = n; SetPageProperty(base);`
	- 将块头按地址有序插入 `free_list`，`nr_free += n`。
- 分配 `default_alloc_pages(n)`：
	- 从 `free_list` 遍历，寻找第一个 `p->property >= n` 的块头；
	- 删除该块头节点，若大于 `n`，在 `page+n` 位置产生新的块头并插回链表；
	- `nr_free -= n; ClearPageProperty(page)`，返回 `page`。
- 释放 `default_free_pages(base, n)`：
	- 确认区间内页均未保留/未属性；清零标志与引用；
	- 将 `base` 标记为新块头并插入有序空闲链表；
	- 与前驱连续则前驱吸收当前：更新前驱 `property`，清除当前 `PageProperty` 并从链表删除；
	- 与后继连续则当前吸收后继：更新当前 `property`，清除后继 `PageProperty` 并从链表删除。

### 复杂度与改进空间

- 当前实现：
	- 分配/释放均可能 O(K) 遍历空闲块数量；
	- 块拆分/合并为 O(1)。
- 改进：
	- 用分级空闲链/按大小排序 + 辅助树结构（如平衡树）降低查找复杂度；
	- 延迟合并或快速合并策略；
	- 碎片优化：适当合并小块或页框回收策略。

---

## 练习2：实现 Best-Fit 连续物理内存分配算法

参考文件：`kern/mm/best_fit_pmm.c`

### 设计与数据结构

- 数据结构与 First-Fit 完全相同：
	- `struct Page`：记录页的引用计数 `ref`、标志位 `flags`、连续空闲块头的大小 `property` 以及链表节点 `page_link`。
	- `free_area_t`：维护空闲块头的双向链表 `free_list` 和空闲页总数 `nr_free`。
- 关键区别在于**分配策略**：不是找到第一个满足条件的块，而是找到**大小最接近需求**的块。

### 核心流程

#### 1. 初始化 `best_fit_init`
与 First-Fit 相同：初始化空闲链表与计数。

#### 2. 建表 `best_fit_init_memmap(base, n)`
我们添加了逻辑：
当找到第一个地址大于 base 的页框 page 时,将 base 插入到它前面,并退出循环
如果遍历到链表末尾(list_next(le) == &free_list)仍未找到更大的地址,说明 base 的地址最大,将其插入链表尾部

#### 3. 分配 `best_fit_alloc_pages(n)` —— **核心改进**
```c
size_t min_size = nr_free + 1;  // 初始化为最大值
struct Page *page = NULL;

// 遍历整个链表，找到最小满足条件的块
while ((le = list_next(le)) != &free_list) {
    struct Page *p = le2page(le, page_link);
    if (p->property >= n && p->property < min_size) {
        page = p;
        min_size = p->property;  // 更新最小值
    }
}
```

**与 First-Fit 的关键区别**：
- First-Fit：找到第一个 `p->property >= n` 就 `break` 返回；
- Best-Fit：遍历**全部**空闲块，记录满足条件中 `property` 最小的块。

**优势**：减少大块被小请求分割导致的外部碎片，提高内存利用率。

**后续处理**（与 First-Fit 相同）：
- 删除该块头节点，若大于 `n`，在 `page+n` 位置产生新的块头并插回链表；
- `nr_free -= n; ClearPageProperty(page)`，返回 `page`。

#### 4. 释放 `best_fit_free_pages(base, n)`
实现与 First-Fit 完全一致：
- 确认区间内页均未保留/未属性；清零标志与引用；
- 设置 `base->property = n; SetPageProperty(base); nr_free += n`；
- 将 `base` 按地址顺序插入有序空闲链表；
- **向前合并**：若前驱块尾 `(p + p->property) == base`，则前驱吸收当前：
	- 更新 `p->property += base->property`；
	- 清除 `ClearPageProperty(base)` 并从链表删除；
	- 更新 `base = p`。
- **向后合并**：若当前块尾 `(base + base->property) == 后继`，则当前吸收后继：
	- 更新 `base->property += 后继->property`；
	- 清除后继 `PageProperty` 并从链表删除。

### 复杂度与改进空间

#### 当前实现
- **时间复杂度**：
	- 分配：O(K)，K 为空闲块数量，必须遍历全部；
	- 释放：O(K)，查找插入位置 + 合并检查；
	- 块拆分/合并：O(1)。
- **空间复杂度**：O(1)，仅使用固定额外变量。

#### 改进方案
1. **分离空闲链表（Segregated Free List）**：
	- 按块大小分类管理（如小块 1-8页、中块 9-32页、大块 33+页）；
	- 分配时直接查找对应大小链表，降低遍历次数；
	- 时间复杂度从 O(K) 降至 O(k)，k 为子链表长度。

2. **平衡树索引（红黑树/AVL树）**：
	- 用平衡树代替链表，按块大小排序；
	- 查找最佳块：O(log K)；
	- 插入/删除：O(log K)；
	- 适用于空闲块数量很大的场景。

## 扩展练习 Challenge：SLUB 分配器（两层架构）

参考文件：`kern/mm/slub_pmm.c`，并在 `pmm.c` 中挂接 `slub_pmm_manager`。

### 目标与架构

- 两层分配：
	1) 页级分配器：用“简化 best-fit”的空闲块管理，接口与 pmm_manager 对齐；
	2) 对象分配器（SLUB）：面向任意（小于等于一页）对象大小的高效分配。

### 数据结构

- 页级：
	- `free_area_t slub_free_area` + 地址有序链 `slub_free_list` + 计数 `slub_nr_free`。
	- 块头 `PageProperty=1, property=#pages`；非头页 `PageProperty=0`。
- SLUB：
	- `kmem_cache_t`：每种对象大小一个 cache（类）；维护 `partial/full/empty` 三个 slab 链表；
	- `slab_t`：位于每页开头，记录 `cache`、`inuse/total`、`free_head`（对象索引 freelist 头）；
	- 尺寸类：`{16,32,64,128,256,512,1024,2048}`，对齐至少为 `sizeof(void*)`。

### 关键算法

- 页级初始化 `slub_page_init_memmap`：清零区间页的 flags/property/ref，`base` 作为块头插回有序空闲链。
- 页级分配 `slub_page_alloc_pages(n)`：
	- 遍历空闲链表，找 `p->property >= n` 的“最佳”块；
	- 如剩余 > n，按 `best+n` 产生新块头插回；
	- 清除 `best` 的 `PageProperty` 并减少 `slub_nr_free`；
	- 返回首页。
- 页级释放合并 `slub_page_free_pages(base,n)`：
	- 检查范围内页不带 Reserved/Property；清零 flags/ref；
	- 设置 `base` 为新块头并插回有序链；
	- 与前驱连续则前驱吸收当前：更新 `pp->property += base->property`，清除 `base` 的 `PageProperty` 与 `property=0`，删除 `base` 链接；
	- 与后继连续则当前吸收后继：更新 `base->property += pn->property`，清除 `pn` 的 `PageProperty` 与 `property=0`，删除 `pn` 链接。

 备注：这一步修复了一个潜在 bug——若不清理被吸收块头的属性位，会在后续释放时触发断言。

- SLUB 建 slab：页级分配一页，将页首作为 `slab_t`，其余作为对象区；对象区用“对象内嵌 16-bit next 索引”的方式管理 freelist。
- kmalloc：选择合适尺寸类 cache；优先从 `partial` 取 slab，否则从 `empty` 取并移入 `partial`，若都无则创建新 slab；从 slab 的 freelist 弹出对象，满则移入 `full`。
- kfree：根据对象地址定位所在 slab（页对齐取 slab 头）；将对象压回 freelist，inuse--；若 inuse==0，销毁 slab 并归还页；否则确保在 `partial` 中。

### 接口契约与正确性

- 契约：`PageProperty=1` 仅在空闲块头页；合并后必须清理被吸收块头属性，确保链表仅包含真实块头。
- 自检：`slub_check()` 覆盖页级分配/合并、地址往返映射、SLUB 多 slab 分配/释放序列，最后空闲页计数回到初始值。

### 复杂度与边界

- 页级分配 O(K)，释放 O(1) 合并 + O(K) 插入；
- SLUB 每次分配/释放基本 O(1)；容量计算考虑对齐与 `slab_t` 头，若对象太大容量为 0 则放弃。
- 边界：
	- kmalloc(0) 返回 NULL；
	- 超过最大尺寸类返回 NULL（可扩展到多页 slab，但本实验简化为一页 slab）。


- 在页级合并时，显式清理被吸收块头页的 `PageProperty` 与 `property=0`，避免隐藏状态污染；
- 调整内核 `cprintf` 的 `%zu` 为 `%lu`，避免最小 printf 不支持 `%zu` 导致日志混乱。

### 测试说明

- 内置 `slub_check()`：
	- 分配 1/2/3 页，检查空闲计数；
	- 释放并跨顺序合并，验证 best-fit 分配能取到合并出来的精确块；
	- 进行 64B 对象的批量分配/释放，跨多个 slab，并在释放后检查空闲页计数是否恢复。

运行验证：QEMU 启动正常，自检通过，无 panic。

---

## 重要知识点总结与原理映射

- 物理内存探测与 DTB：
	- 原理：OpenSBI/Bootloader 提供设备树，OS 解析 DRAM 范围；
	- 实验：`dtb.c` 获取 base/size，`pmm.c:page_init()` 通过 DTB 设置 `npage/pages/freemem` 后建立空闲链。

- 页框描述与双向链表管理：
	- 原理：为每个页框建立元信息结构（flags/ref/property）；
	- 实验：`struct Page` + `list.h` 维护空闲块头链；按地址有序便于相邻合并。

- 连续物理内存分配策略：First-Fit vs Best-Fit：
	- 原理：不同策略下外部碎片与搜索代价权衡；
	- 实验：`default_pmm.c` 与 `best_fit_pmm.c` 的实现与测试。

- 高地址映射与页表启用：
	- 原理：内核高半区映射，SATP/Sv39，大页映射；
	- 实验：`entry.S` 预置三级页表，将 0xffffffffc0000000~ 映射到 0x80000000~。

- SLUB 小对象分配：
	- 原理：按尺寸类的 slab，嵌入式 freelist，最小元数据开销；
	- 实验：`slub_pmm.c` 中以页为 slab，头放页首，空闲对象用 16-bit 索引链接，空 slab 立即归还页，简化但体现主体思想。

### 实验与原理的差异/取舍

- 简化：
	- SLUB 未实现对象构造/析构、cache 对齐/颜色化、NUMA、跨页 slab、大对象分配等；
	- 页级分配未采用复杂数据结构优化搜索复杂度。
- 强调：
	- 契约清晰（块头唯一性、属性位语义），便于验证与扩展；
	- 自检覆盖合并边界与对象级回收。

---

## 原理重要但本实验未覆盖的内容

- 伙伴系统（Buddy）与高阶页管理、抗碎片策略。
- Slab/SLUB 的 kmem_cache_ctor/dtor、对象对齐与 cache 合并、延迟回收、每 CPU 变量与缓存对齐、NUMA 感知。
- 页面替换算法（FIFO/LRU/Clock）与缺页异常处理。
- 虚拟内存权限隔离（用户/内核态）、Copy-on-Write、内存映射文件、匿名映射等。
- IOMMU 与 DMA 映射，页面锁定与高端内存管理。

---

## 遇到的问题与解决

- 问题：释放页块合并时未清理被吸收块头的 `PageProperty`，导致后续释放触发断言（日志中 flags=2/prop=2）。
	- 解决：在 `slub_page_free_pages` 的前驱/后继合并中，显式 `ClearPageProperty()` 并将被吸收头的 `property=0`。

- 问题：`cprintf` 不支持 `%zu`，日志出现 `%zu` 字面量。
	- 解决：统一改为 `%lu` 并进行 `(unsigned long)` 强制转换。

---

## 代码位置索引

- First-Fit：`kern/mm/default_pmm.c`
- Best-Fit：`kern/mm/best_fit_pmm.c`
- SLUB 两层分配器：`kern/mm/slub_pmm.c`
- 管理器接入：`kern/mm/pmm.c`（`pmm_manager = &slub_pmm_manager;`）
- 核心结构体/宏：`kern/mm/memlayout.h`，链表：`libs/list.h`

---

## 练习3：硬件的可用物理内存范围的获取方法
核心思路是​​通过固件提供的标准接口来查询硬件信息。


| 探测方法 | 工作机制简介 | 
| :--- | :--- |
| **BIOS 中断 `0x15`，子功能 `0xE820`** | 通过多次调用中断，固件迭代返回多个**地址范围描述符（ARDS）**，每个描述符告知操作系统一段内存的起始地址、长度和类型（如可用、保留等）。 | 
| **BIOS 中断 `0x15`，子功能 `0xE801`** | 一种简化的方法，将内存分为两部分检测：0-15MB区域和16MB-4GB区域，结果分别存放在不同的寄存器中。 | 
| **BIOS 中断 `0x15`，子功能 `0x88`** | 最简单的方法，调用后直接返回1MB地址以上、最多64MB范围内的内存大小（以KB为单位）。 |
| **通过 SBI HSM 扩展获取** | 调用 SBI 接口获取内存区域数量，查询具体的内存区域信息，通过标志位区分可用内存和保留内存|
 **通过平台特定接口获取**|通过 sbi_platform_ptr 获取平台信息结构体，遍历平台定义的内存区域数组，检查区域的可用性标志|
 |**保守内存探测**|从已知安全地址开始逐页测试读写，检查是否能成功写入和读取数据。|

